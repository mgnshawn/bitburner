var ownedServers = {'home':'home'};
var highestLevelSeen = 1;
var scriptRam = 0;
var purchaseServers = false;
var level1 = false;
var level2 = false;
var level3 = false;
var level4 = false;
var level5 = false;
var crackers = 0;
var networkMap = {'home':{}};
var contractsFound = [];
var onlyHunting = false;
var designateTarget = false;
var quiet = true;

// args Ram, Slices, Target
export async function main(ns) {
    if(ns.args[0] !== undefined && (ns.args[0] == "-h" || ns.args[0] == '-?')) {
        await ns.tprint("freshstart.ns Req:(n||Ram in GB)   Req:(slice count)  (-d||designated target)  (-o for only hunting) (-v verbose) ");
        await ns.tprint("Options:Purchase servers     This can run against net servers only or also buy player owned. If buying, specify the starting ram in GB, it will continue to evolve the servers size once the max has been purchased.");
        await ns.tprint("Options:Slice count     How many copies of the hackit.ns app should run. More yields better overall returns. The thread count will be calculated based on server size and slice count. Minimum 1");
        await ns.tprint("Options:Designate Target     Designate a server all conquered servers should attack, if not designated then conquered servers will be set to target themselves.");
        await ns.tprint("Options:Only Hunting    This only spiders the net for contract files or the-cave. All locations of contracts will be written to found.contracts");
        await ns.tprint("The app will discover the network and attempt to conquer any server below your level that you have appropriate crackers for. It will continue this loop as you continue to level up. It will also make sure all your owned servers are running the hackit.ns script at full levels starting with home. If set to purchase servers, it will purchase servers at the memory level specified. Once 25 servers have been purchased it will recycle the oldest and purchase a server at the next memory size.");
        ns.exit();
    }

    if(ns.fileExists("BruteSSH.exe"))
        crackers++;
    if(ns.fileExists("FTPCrack.exe"))
        crackers++;
    if(ns.fileExists("relaySMTP.exe"))
        crackers++;
    if(ns.fileExists("HTTPWorm.exe"))
        crackers++;
    if(ns.fileExists("SQLInject.exe"))
        crackers++;
    scriptRam = ns.getScriptRam('hackit.ns');
    if(ns.args[0] == 'n' || ns.args[0] == "N") {
        purchaseServers = false;
    } else {
        purchaseServers = true;
    }
    var ram = ns.args[0];
    var slice = ns.args[1];
    
    var target = "";
    var l1 = 128*1024;
    var l2 = 512 * 1024;
    var lf = 1024*1024;
    var memmoryLevels = [16,32,256,1024,2048,4096,32768,l1,l2,lf];
    var currentServerLevelIndex = 0;
    if(ram == 'n') {
        ram = 8;
    }
    for(var l = 0; l < memmoryLevels.length; l++) {
        if(ram > memmoryLevels[l]) {
            currentServerLevelIndex = l;
        }
    }
    var currentServerLevel = memmoryLevels[currentServerLevelIndex];

    if(ns.args[2] == undefined || ns.args[2] == '-d' || ns.args[2] == '-D') {
        designateTarget = false;
    } else {
        designateTarget = true;
        target = ns.args[2];
    }
    if(ns.args[3] !== undefined && (ns.args[3] == '-o' || ns.args[3] == '-O')) {
        onlyHunting = true;
    }
    if(ns.args[4] !== undefined && ns.args[4] == '-v') {
        quiet = false;
    }

    level2 = false;level3 = false;level4=false;level5=false;
    if(!quiet)await ns.tprint("Cost to purchase these servers: "+ns.getPurchasedServerCost(ram));


    var serv = 'home';
    var rand = Math.random();
    
    if(designateTarget === false) {
        target = serv;
    }
    var threads = Math.floor((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv))/scriptRam);
    if(threads < 1) {
        threads = 1;
    }
    await ns.run("hackit.ns", threads, target);
        if((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv)) > Math.ceil(scriptRam)) {
            var extraCopies = Math.floor((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv))/scriptRam);
            if(extraCopies > 0) {
                if(!quiet)await ns.tprint("Starting "+extraCopies+" extra hackit threads on "+serv);
                await ns.run("hackit.ns", extraCopies, target, rand, extraCopies);                
            }
        }
        rand = Math.random();
    serv = 'n00dles';
    if(designateTarget === false) {
        target = serv;
    }
    var threads = Math.floor((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv))/scriptRam);
    if(threads < 1) {
        threads = 1;
    }
    await ns.run("hackit.ns", threads, target);
        if((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv)) > Math.ceil(scriptRam)) {
            var extraCopies = Math.floor((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv))/scriptRam);
            if(extraCopies > 0) {
                if(!quiet)await ns.tprint("Starting "+extraCopies+" extra hackit threads on "+serv);
                await ns.exec("hackit.ns",serv, extraCopies, target, rand, extraCopies);                
            }
        }

// Make sure our servers are running optimal threads
if(designateTarget !== false ) {
    var attackServers = await ns.getPurchasedServers();
    for(var a = 0; a < attackServers.length; a++) {
        var serv = attackServers[a];
        rand = Math.random();
        if((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv)) > Math.ceil(scriptRam)) {
            var extraCopies = Math.floor((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv))/scriptRam);
            if(extraCopies > 0) {
                if(!quiet)await ns.tprint("Starting "+extraCopies+" extra hackit threads on owned server: "+serv);
                await ns.exec("hackit.ns", serv, extraCopies, target, rand, extraCopies);                
            }
        }
    }
}


var i = 0;

// Continuously try to purchase servers until we've reached the maximum
while (purchaseServers == true && !onlyHunting && i < ns.getPurchasedServerLimit() && ns.getPurchasedServers().length < ns.getPurchasedServerLimit()) {
    crackers = 0;
    if(ns.fileExists("BruteSSH.exe"))
        crackers++;
    if(ns.fileExists("FTPCrack.exe"))
        crackers++;
    if(ns.fileExists("relaySMTP.exe"))
        crackers++;
    if(ns.fileExists("HTTPWorm.exe"))
        crackers++;
    if(ns.fileExists("SQLInject.exe"))
        crackers++;
    // Check if we have enough money to purchase a server
    
    if (ns.getServerMoneyAvailable("home") > ns.getPurchasedServerCost(ram)) {
        
        var hostname = ns.purchaseServer("attack-"+target+"-"+(ram)+"gb-"+ i, (ram));
        for(var s=1;s<=slice;s++) {
            await ns.scp("hackit.ns", hostname);
            await ns.exec("hackit.ns", hostname, Math.floor((ram)/Math.ceil(scriptRam)/slice), target,s);
            await ns.sleep(300);
        }
        if((ns.getServerMaxRam(hostname) - ns.getServerUsedRam(hostname)) > Math.ceil(scriptRam)) {
            var extraCopies = Math.floor((ns.getServerMaxRam(hostname) - ns.getServerUsedRam(hostname))/scriptRam);
                if(!quiet)await ns.tprint("Starting "+extraCopies+" extra hackit threads on "+hostname);
                await ns.exec("hackit.ns", hostname, extraCopies, target, s, extraCopies);                
        }
        ++i;
    }

    if(!quiet)ns.tprint("Spidering...");
    await scanServer(ns,{'home':'home'}, target, 0);
    await ns.sleep(10000);
}
if(!quiet)await ns.tprint("Moving on to upgrade loop...");
while (purchaseServers == true && !onlyHunting &&  currentServerLevel <= memmoryLevels[(memmoryLevels.length-1)]) {
    crackers = 0;
    if(ns.fileExists("BruteSSH.exe"))
        crackers++;
    if(ns.fileExists("FTPCrack.exe"))
        crackers++;
    if(ns.fileExists("relaySMTP.exe"))
        crackers++;
    if(ns.fileExists("HTTPWorm.exe"))
        crackers++;
    if(ns.fileExists("SQLInject.exe"))
        crackers++;
    var upgrade = true;
    var servers = ns.getPurchasedServers();
   
        if(ns.getServerMoneyAvailable("home") > ns.getPurchasedServerCost(currentServerLevel)) {
        for(var a = 0; a < 25; a++) {
            if(ns.getServerMoneyAvailable("home") > ns.getPurchasedServerCost(currentServerLevel)) {
                if(ns.getServerMaxRam(servers[a]) < currentServerLevel) {
                    if(!quiet)await ns.tprint("Upgrading "+servers[a]+" from "+ ns.getServerMaxRam(servers[a])+" to "+currentServerLevel);
                    var skillSuck = ns.scriptKill("hackit.ns",servers[a]);                    
                    var delSuc = ns.deleteServer(servers[a]);
                    if(delSuc == true) {
                    if(!quiet)await ns.tprint(" Deleted "+servers[a]);
                    upgrade = false;
                    } else {
                        if(!quiet)await ns.tprint("  Problem Deleting "+servers[a]);
                        if(skillSuck == true) {
                            if(!quiet)await ns.tprint("   Suceeded in killing hackit.ns");
                        } else {
                            if(!quiet)await ns.tprint("   Failed to kill hackit.ns");
                        }
                    }
                    
                    var hostname = ns.purchaseServer("attack-"+target+"-"+(currentServerLevel)+"gb-"+ i, (currentServerLevel));
                    if(!quiet)await ns.tprint(" Purchased "+hostname);
                    for(var s=1;s<=slice;s++) {
                        await ns.scp("hackit.ns", hostname);
                        await ns.exec("hackit.ns", hostname, Math.floor((currentServerLevel)/Math.ceil(scriptRam)/slice), target,s);
                        await ns.sleep(100);
                    }
                    if((ns.getServerMaxRam(hostname) - ns.getServerUsedRam(hostname)) > Math.ceil(scriptRam)) {
                        var extraCopies = Math.floor((ns.getServerMaxRam(hostname) - ns.getServerUsedRam(hostname))/scriptRam);
                        if(!quiet)await ns.tprint("Starting "+extraCopies+" extra hackit threads on "+hostname);
                        await ns.exec("hackit.ns", hostname, extraCopies, target, s, extraCopies);                
                    }
                }
            }
            
        } 
        } else {
                if(!quiet)await ns.tprint("Not enough money to upgrade yet, need: "+ns.getPurchasedServerCost(currentServerLevel));
                await ns.sleep(60000);
        }
        for(var a = 0;a < ns.getPurchasedServers().length; a++) {
            if(upgrade == false || ns.getServerMaxRam(servers[a]) < currentServerLevel) {
                upgrade = false;
            }
        }
        if(upgrade == true) {            
            currentServerLevelIndex++;
            currentServerLevel = memmoryLevels[currentServerLevelIndex];
            if(!quiet)await ns.tprint("-- Setting Upgrade Server Ram to "+currentServerLevel);
            if(!quiet)await ns.tprint("    New server cost: "+ns.getPurchasedServerCost(currentServerLevel));
            upgrade = false;
        }
        upgrade = true;
        await ns.sleep(10000);
        if(!quiet)ns.tprint("Spidering...");
        await scanServer(ns,{'home':'home'}, target, 0);
    }

    while(true) {
        crackers = 0;
        if(ns.fileExists("BruteSSH.exe"))
            crackers++;
        if(ns.fileExists("FTPCrack.exe"))
            crackers++;
        if(ns.fileExists("relaySMTP.exe"))
            crackers++;
        if(ns.fileExists("HTTPWorm.exe"))
            crackers++;
        if(ns.fileExists("SQLInject.exe"))
            crackers++;

        if(!quiet)ns.tprint("Spidering...");
        await scanServer(ns,{'home':'home'}, target, 0);
        await ns.sleep(60000);
    }
}



// depricated
/** @param {NS} ns **/
/*
async function spider(ns) {
	var player = ns.getPlayer();
	var playerLevel = player.hacking;
	while(highestLevelSeen < 1200) {
	for(var a = 0;a < Object.index(ownedServers).length; a++) {
		await scanServer(ns,ownedServers[a]);
	}
	await ns.sleep(200);
	}
}*/

async function scanServer(ns,source, target, level) {
    level++;
    var spacer = "";
    for(var sp=0; sp < level; sp++) {
        spacer = spacer+" ";
    }
    if(!quiet)ns.tprint(spacer+"Scanning "+Object.keys(source)[0]+" coming from "+source[Object.keys(source)[0]]+"...");
    let files = ns.ls(Object.keys(source)[0],".cct");
    if(files !== undefined && files !== null && files.length > 0) {
        if(!contractsFound.includes(Object.keys(source)[0])) {
           contractsFound.push(Object.keys(source)[0]);
           if(!quiet)ns.tprint("                                        CONTRACT FOUND ||||||||||||||||||||||||");
           await ns.write("found.contracts",contractsFound,"w");
        }
    }
	var connectionsp = ns.scan(Object.keys(source)[0]);
    var connections = [];
	for(var c = 0; c < connectionsp.length;c++) {        
        if(connectionsp[c] != source[Object.keys(source)[0]]) {
            var serverInfo = ns.getServer(connectionsp[c]);
            if(serverInfo.purchasedByPlayer != true) {
                connections.push(connectionsp[c]);
                if(!quiet)ns.tprint("kept "+connectionsp[c]);
            }
        }
    }
		
        
    for(var a = 0; a < connections.length; a++) {
        await ns.sleep(150);
        if(!quiet)ns.tprint("=>"+connections[a]);        
        if(connections[a] == "The-Cave") {
            if(!quiet)ns.tprint("===================================== FOUND IT ======================================");
            if(onlyHunting) {
                ns.exit();
            }
        }
         var result = await evalAndNuke(ns,connections[a],Object.keys(source)[0], target);
        var nextUp = {};
        nextUp[connections[a]]=Object.keys(source)[0];
        await scanServer(ns,nextUp,target,level );
        
    }
}

async function evalAndNuke(ns,server,origin,target) {
        if(!quiet)ns.tprint("   ..evaluating "+server);
		var attackThis = server;
		var serverInfo = ns.getServer(attackThis);
		var returnResult = false;
		var player = ns.getPlayer();
		var playerLevel = player.hacking;
		if(serverInfo.purchasedByPlayer == true) {
			return false;
		}
		if(serverInfo.hasAdminRights == true) {
			if(!Object.keys(ownedServers).includes(server)) {
				ownedServers[server]=origin;
			}			
		}
		var level = ns.getServerRequiredHackingLevel(attackThis);
		
		if(highestLevelSeen < level) {
			highestLevelSeen = level;
		}
		if(level <= playerLevel &&  ((ns.getServerMaxRam(attackThis) - ns.getServerUsedRam(attackThis)) > Math.ceil(scriptRam) || (ns.getServerMaxRam(attackThis) < Math.ceil(scriptRam)))) {
            if(crackers >= ns.getServerNumPortsRequired(attackThis)) {
                if(ns.fileExists("BruteSSH.exe"))
                    ns.brutessh(attackThis);
                if(ns.fileExists("FTPCrack.exe"))
                    ns.ftpcrack(attackThis);
                if(ns.fileExists("relaySMTP.exe"))
                    ns.relaysmtp(attackThis);
                if(ns.fileExists("HTTPWorm.exe"))
                    ns.httpworm(attackThis);
                if(ns.fileExists("SQLInject.exe"))
			        ns.sqlinject(attackThis);
		    
    			returnResult = ns.nuke(attackThis);
	    		ownedServers[server]=origin;
		    	if(!quiet)ns.tprint(" ...conquered "+attackThis);
                await startHacking(ns,server,target);
            }
		}
		return returnResult;
}

async function startHacking(ns,serv,thisTarget) {


    await ns.scp("hackit.ns", serv);
    
    var targetRam = ns.getServerMaxRam(serv);
    var threads = Math.floor(targetRam/Math.ceil(ns.getScriptRam("hackit.ns")));
    if(threads < 1) {
        threads = 1;
    }
    var rand = Math.random();
    await ns.exec("hackit.ns", serv, threads, thisTarget, rand);
        if((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv)) > Math.ceil(scriptRam)) {
            var extraCopies = Math.floor((ns.getServerMaxRam(serv) - ns.getServerUsedRam(serv))/scriptRam);
            if(extraCopies > 0) {
                if(!quiet)await ns.tprint("Starting "+extraCopies+" extra hackit threads on "+serv);
                await ns.exec("hackit.ns", serv, extraCopies, thisTarget, rand, extraCopies);                
            }
        }    
}